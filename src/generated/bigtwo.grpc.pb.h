// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bigtwo.proto
#ifndef GRPC_bigtwo_2eproto__INCLUDED
#define GRPC_bigtwo_2eproto__INCLUDED

#include "bigtwo.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace bigtwo {

// ---------------------------------------------------------------------------
// 前台遊戲主要功能
// ---------------------------------------------------------------------------
class BigTwoService final {
 public:
  static constexpr char const* service_full_name() {
    return "bigtwo.BigTwoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status PlayCards(::grpc::ClientContext* context, const ::bigtwo::PlayRequest& request, ::bigtwo::PlayResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayResponse>> AsyncPlayCards(::grpc::ClientContext* context, const ::bigtwo::PlayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayResponse>>(AsyncPlayCardsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayResponse>> PrepareAsyncPlayCards(::grpc::ClientContext* context, const ::bigtwo::PlayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayResponse>>(PrepareAsyncPlayCardsRaw(context, request, cq));
    }
    virtual ::grpc::Status Pass(::grpc::ClientContext* context, const ::bigtwo::PassRequest& request, ::bigtwo::PassResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PassResponse>> AsyncPass(::grpc::ClientContext* context, const ::bigtwo::PassRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PassResponse>>(AsyncPassRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PassResponse>> PrepareAsyncPass(::grpc::ClientContext* context, const ::bigtwo::PassRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PassResponse>>(PrepareAsyncPassRaw(context, request, cq));
    }
    virtual ::grpc::Status GetGameState(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest& request, ::bigtwo::GameStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::GameStateResponse>> AsyncGetGameState(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::GameStateResponse>>(AsyncGetGameStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::GameStateResponse>> PrepareAsyncGetGameState(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::GameStateResponse>>(PrepareAsyncGetGameStateRaw(context, request, cq));
    }
    virtual ::grpc::Status JoinGame(::grpc::ClientContext* context, const ::bigtwo::JoinRequest& request, ::bigtwo::JoinResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::JoinResponse>> AsyncJoinGame(::grpc::ClientContext* context, const ::bigtwo::JoinRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::JoinResponse>>(AsyncJoinGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::JoinResponse>> PrepareAsyncJoinGame(::grpc::ClientContext* context, const ::bigtwo::JoinRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::JoinResponse>>(PrepareAsyncJoinGameRaw(context, request, cq));
    }
    virtual ::grpc::Status Chat(::grpc::ClientContext* context, const ::bigtwo::ChatRequest& request, ::bigtwo::ChatResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ChatResponse>> AsyncChat(::grpc::ClientContext* context, const ::bigtwo::ChatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ChatResponse>>(AsyncChatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ChatResponse>> PrepareAsyncChat(::grpc::ClientContext* context, const ::bigtwo::ChatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ChatResponse>>(PrepareAsyncChatRaw(context, request, cq));
    }
    // 新增：可以由遊戲主持人/server 觸發遊戲開始
    virtual ::grpc::Status StartGame(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest& request, ::bigtwo::StartGameResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::StartGameResponse>> AsyncStartGame(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::StartGameResponse>>(AsyncStartGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::StartGameResponse>> PrepareAsyncStartGame(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::StartGameResponse>>(PrepareAsyncStartGameRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void PlayCards(::grpc::ClientContext* context, const ::bigtwo::PlayRequest* request, ::bigtwo::PlayResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlayCards(::grpc::ClientContext* context, const ::bigtwo::PlayRequest* request, ::bigtwo::PlayResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Pass(::grpc::ClientContext* context, const ::bigtwo::PassRequest* request, ::bigtwo::PassResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Pass(::grpc::ClientContext* context, const ::bigtwo::PassRequest* request, ::bigtwo::PassResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetGameState(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest* request, ::bigtwo::GameStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGameState(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest* request, ::bigtwo::GameStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void JoinGame(::grpc::ClientContext* context, const ::bigtwo::JoinRequest* request, ::bigtwo::JoinResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void JoinGame(::grpc::ClientContext* context, const ::bigtwo::JoinRequest* request, ::bigtwo::JoinResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Chat(::grpc::ClientContext* context, const ::bigtwo::ChatRequest* request, ::bigtwo::ChatResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Chat(::grpc::ClientContext* context, const ::bigtwo::ChatRequest* request, ::bigtwo::ChatResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 新增：可以由遊戲主持人/server 觸發遊戲開始
      virtual void StartGame(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest* request, ::bigtwo::StartGameResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartGame(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest* request, ::bigtwo::StartGameResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayResponse>* AsyncPlayCardsRaw(::grpc::ClientContext* context, const ::bigtwo::PlayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayResponse>* PrepareAsyncPlayCardsRaw(::grpc::ClientContext* context, const ::bigtwo::PlayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PassResponse>* AsyncPassRaw(::grpc::ClientContext* context, const ::bigtwo::PassRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PassResponse>* PrepareAsyncPassRaw(::grpc::ClientContext* context, const ::bigtwo::PassRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::GameStateResponse>* AsyncGetGameStateRaw(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::GameStateResponse>* PrepareAsyncGetGameStateRaw(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::JoinResponse>* AsyncJoinGameRaw(::grpc::ClientContext* context, const ::bigtwo::JoinRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::JoinResponse>* PrepareAsyncJoinGameRaw(::grpc::ClientContext* context, const ::bigtwo::JoinRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ChatResponse>* AsyncChatRaw(::grpc::ClientContext* context, const ::bigtwo::ChatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ChatResponse>* PrepareAsyncChatRaw(::grpc::ClientContext* context, const ::bigtwo::ChatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::StartGameResponse>* AsyncStartGameRaw(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::StartGameResponse>* PrepareAsyncStartGameRaw(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status PlayCards(::grpc::ClientContext* context, const ::bigtwo::PlayRequest& request, ::bigtwo::PlayResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayResponse>> AsyncPlayCards(::grpc::ClientContext* context, const ::bigtwo::PlayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayResponse>>(AsyncPlayCardsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayResponse>> PrepareAsyncPlayCards(::grpc::ClientContext* context, const ::bigtwo::PlayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayResponse>>(PrepareAsyncPlayCardsRaw(context, request, cq));
    }
    ::grpc::Status Pass(::grpc::ClientContext* context, const ::bigtwo::PassRequest& request, ::bigtwo::PassResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PassResponse>> AsyncPass(::grpc::ClientContext* context, const ::bigtwo::PassRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PassResponse>>(AsyncPassRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PassResponse>> PrepareAsyncPass(::grpc::ClientContext* context, const ::bigtwo::PassRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PassResponse>>(PrepareAsyncPassRaw(context, request, cq));
    }
    ::grpc::Status GetGameState(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest& request, ::bigtwo::GameStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::GameStateResponse>> AsyncGetGameState(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::GameStateResponse>>(AsyncGetGameStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::GameStateResponse>> PrepareAsyncGetGameState(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::GameStateResponse>>(PrepareAsyncGetGameStateRaw(context, request, cq));
    }
    ::grpc::Status JoinGame(::grpc::ClientContext* context, const ::bigtwo::JoinRequest& request, ::bigtwo::JoinResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::JoinResponse>> AsyncJoinGame(::grpc::ClientContext* context, const ::bigtwo::JoinRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::JoinResponse>>(AsyncJoinGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::JoinResponse>> PrepareAsyncJoinGame(::grpc::ClientContext* context, const ::bigtwo::JoinRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::JoinResponse>>(PrepareAsyncJoinGameRaw(context, request, cq));
    }
    ::grpc::Status Chat(::grpc::ClientContext* context, const ::bigtwo::ChatRequest& request, ::bigtwo::ChatResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ChatResponse>> AsyncChat(::grpc::ClientContext* context, const ::bigtwo::ChatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ChatResponse>>(AsyncChatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ChatResponse>> PrepareAsyncChat(::grpc::ClientContext* context, const ::bigtwo::ChatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ChatResponse>>(PrepareAsyncChatRaw(context, request, cq));
    }
    ::grpc::Status StartGame(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest& request, ::bigtwo::StartGameResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::StartGameResponse>> AsyncStartGame(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::StartGameResponse>>(AsyncStartGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::StartGameResponse>> PrepareAsyncStartGame(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::StartGameResponse>>(PrepareAsyncStartGameRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void PlayCards(::grpc::ClientContext* context, const ::bigtwo::PlayRequest* request, ::bigtwo::PlayResponse* response, std::function<void(::grpc::Status)>) override;
      void PlayCards(::grpc::ClientContext* context, const ::bigtwo::PlayRequest* request, ::bigtwo::PlayResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Pass(::grpc::ClientContext* context, const ::bigtwo::PassRequest* request, ::bigtwo::PassResponse* response, std::function<void(::grpc::Status)>) override;
      void Pass(::grpc::ClientContext* context, const ::bigtwo::PassRequest* request, ::bigtwo::PassResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetGameState(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest* request, ::bigtwo::GameStateResponse* response, std::function<void(::grpc::Status)>) override;
      void GetGameState(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest* request, ::bigtwo::GameStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void JoinGame(::grpc::ClientContext* context, const ::bigtwo::JoinRequest* request, ::bigtwo::JoinResponse* response, std::function<void(::grpc::Status)>) override;
      void JoinGame(::grpc::ClientContext* context, const ::bigtwo::JoinRequest* request, ::bigtwo::JoinResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Chat(::grpc::ClientContext* context, const ::bigtwo::ChatRequest* request, ::bigtwo::ChatResponse* response, std::function<void(::grpc::Status)>) override;
      void Chat(::grpc::ClientContext* context, const ::bigtwo::ChatRequest* request, ::bigtwo::ChatResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartGame(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest* request, ::bigtwo::StartGameResponse* response, std::function<void(::grpc::Status)>) override;
      void StartGame(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest* request, ::bigtwo::StartGameResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayResponse>* AsyncPlayCardsRaw(::grpc::ClientContext* context, const ::bigtwo::PlayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayResponse>* PrepareAsyncPlayCardsRaw(::grpc::ClientContext* context, const ::bigtwo::PlayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::PassResponse>* AsyncPassRaw(::grpc::ClientContext* context, const ::bigtwo::PassRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::PassResponse>* PrepareAsyncPassRaw(::grpc::ClientContext* context, const ::bigtwo::PassRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::GameStateResponse>* AsyncGetGameStateRaw(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::GameStateResponse>* PrepareAsyncGetGameStateRaw(::grpc::ClientContext* context, const ::bigtwo::GameStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::JoinResponse>* AsyncJoinGameRaw(::grpc::ClientContext* context, const ::bigtwo::JoinRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::JoinResponse>* PrepareAsyncJoinGameRaw(::grpc::ClientContext* context, const ::bigtwo::JoinRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::ChatResponse>* AsyncChatRaw(::grpc::ClientContext* context, const ::bigtwo::ChatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::ChatResponse>* PrepareAsyncChatRaw(::grpc::ClientContext* context, const ::bigtwo::ChatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::StartGameResponse>* AsyncStartGameRaw(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::StartGameResponse>* PrepareAsyncStartGameRaw(::grpc::ClientContext* context, const ::bigtwo::StartGameRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PlayCards_;
    const ::grpc::internal::RpcMethod rpcmethod_Pass_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGameState_;
    const ::grpc::internal::RpcMethod rpcmethod_JoinGame_;
    const ::grpc::internal::RpcMethod rpcmethod_Chat_;
    const ::grpc::internal::RpcMethod rpcmethod_StartGame_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status PlayCards(::grpc::ServerContext* context, const ::bigtwo::PlayRequest* request, ::bigtwo::PlayResponse* response);
    virtual ::grpc::Status Pass(::grpc::ServerContext* context, const ::bigtwo::PassRequest* request, ::bigtwo::PassResponse* response);
    virtual ::grpc::Status GetGameState(::grpc::ServerContext* context, const ::bigtwo::GameStateRequest* request, ::bigtwo::GameStateResponse* response);
    virtual ::grpc::Status JoinGame(::grpc::ServerContext* context, const ::bigtwo::JoinRequest* request, ::bigtwo::JoinResponse* response);
    virtual ::grpc::Status Chat(::grpc::ServerContext* context, const ::bigtwo::ChatRequest* request, ::bigtwo::ChatResponse* response);
    // 新增：可以由遊戲主持人/server 觸發遊戲開始
    virtual ::grpc::Status StartGame(::grpc::ServerContext* context, const ::bigtwo::StartGameRequest* request, ::bigtwo::StartGameResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PlayCards() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayRequest* /*request*/, ::bigtwo::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayCards(::grpc::ServerContext* context, ::bigtwo::PlayRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::PlayResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Pass() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::bigtwo::PassRequest* /*request*/, ::bigtwo::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPass(::grpc::ServerContext* context, ::bigtwo::PassRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::PassResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGameState() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::bigtwo::GameStateRequest* /*request*/, ::bigtwo::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGameState(::grpc::ServerContext* context, ::bigtwo::GameStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::GameStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JoinGame() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::bigtwo::JoinRequest* /*request*/, ::bigtwo::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoinGame(::grpc::ServerContext* context, ::bigtwo::JoinRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::JoinResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Chat() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::bigtwo::ChatRequest* /*request*/, ::bigtwo::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChat(::grpc::ServerContext* context, ::bigtwo::ChatRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::ChatResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartGame() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::bigtwo::StartGameRequest* /*request*/, ::bigtwo::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartGame(::grpc::ServerContext* context, ::bigtwo::StartGameRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::StartGameResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PlayCards<WithAsyncMethod_Pass<WithAsyncMethod_GetGameState<WithAsyncMethod_JoinGame<WithAsyncMethod_Chat<WithAsyncMethod_StartGame<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PlayCards() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::PlayRequest, ::bigtwo::PlayResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::PlayRequest* request, ::bigtwo::PlayResponse* response) { return this->PlayCards(context, request, response); }));}
    void SetMessageAllocatorFor_PlayCards(
        ::grpc::MessageAllocator< ::bigtwo::PlayRequest, ::bigtwo::PlayResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::PlayRequest, ::bigtwo::PlayResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayRequest* /*request*/, ::bigtwo::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayCards(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::PlayRequest* /*request*/, ::bigtwo::PlayResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Pass() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::PassRequest, ::bigtwo::PassResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::PassRequest* request, ::bigtwo::PassResponse* response) { return this->Pass(context, request, response); }));}
    void SetMessageAllocatorFor_Pass(
        ::grpc::MessageAllocator< ::bigtwo::PassRequest, ::bigtwo::PassResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::PassRequest, ::bigtwo::PassResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::bigtwo::PassRequest* /*request*/, ::bigtwo::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Pass(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::PassRequest* /*request*/, ::bigtwo::PassResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetGameState() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::GameStateRequest, ::bigtwo::GameStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::GameStateRequest* request, ::bigtwo::GameStateResponse* response) { return this->GetGameState(context, request, response); }));}
    void SetMessageAllocatorFor_GetGameState(
        ::grpc::MessageAllocator< ::bigtwo::GameStateRequest, ::bigtwo::GameStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::GameStateRequest, ::bigtwo::GameStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::bigtwo::GameStateRequest* /*request*/, ::bigtwo::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGameState(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::GameStateRequest* /*request*/, ::bigtwo::GameStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_JoinGame() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::JoinRequest, ::bigtwo::JoinResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::JoinRequest* request, ::bigtwo::JoinResponse* response) { return this->JoinGame(context, request, response); }));}
    void SetMessageAllocatorFor_JoinGame(
        ::grpc::MessageAllocator< ::bigtwo::JoinRequest, ::bigtwo::JoinResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::JoinRequest, ::bigtwo::JoinResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::bigtwo::JoinRequest* /*request*/, ::bigtwo::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JoinGame(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::JoinRequest* /*request*/, ::bigtwo::JoinResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Chat() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::ChatRequest, ::bigtwo::ChatResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::ChatRequest* request, ::bigtwo::ChatResponse* response) { return this->Chat(context, request, response); }));}
    void SetMessageAllocatorFor_Chat(
        ::grpc::MessageAllocator< ::bigtwo::ChatRequest, ::bigtwo::ChatResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::ChatRequest, ::bigtwo::ChatResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::bigtwo::ChatRequest* /*request*/, ::bigtwo::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Chat(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::ChatRequest* /*request*/, ::bigtwo::ChatResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartGame() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::StartGameRequest, ::bigtwo::StartGameResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::StartGameRequest* request, ::bigtwo::StartGameResponse* response) { return this->StartGame(context, request, response); }));}
    void SetMessageAllocatorFor_StartGame(
        ::grpc::MessageAllocator< ::bigtwo::StartGameRequest, ::bigtwo::StartGameResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::StartGameRequest, ::bigtwo::StartGameResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::bigtwo::StartGameRequest* /*request*/, ::bigtwo::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartGame(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::StartGameRequest* /*request*/, ::bigtwo::StartGameResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_PlayCards<WithCallbackMethod_Pass<WithCallbackMethod_GetGameState<WithCallbackMethod_JoinGame<WithCallbackMethod_Chat<WithCallbackMethod_StartGame<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PlayCards() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayRequest* /*request*/, ::bigtwo::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Pass() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::bigtwo::PassRequest* /*request*/, ::bigtwo::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGameState() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::bigtwo::GameStateRequest* /*request*/, ::bigtwo::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JoinGame() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::bigtwo::JoinRequest* /*request*/, ::bigtwo::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Chat() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::bigtwo::ChatRequest* /*request*/, ::bigtwo::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartGame() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::bigtwo::StartGameRequest* /*request*/, ::bigtwo::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PlayCards() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayRequest* /*request*/, ::bigtwo::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayCards(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Pass() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::bigtwo::PassRequest* /*request*/, ::bigtwo::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPass(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGameState() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::bigtwo::GameStateRequest* /*request*/, ::bigtwo::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGameState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JoinGame() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::bigtwo::JoinRequest* /*request*/, ::bigtwo::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoinGame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Chat() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::bigtwo::ChatRequest* /*request*/, ::bigtwo::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartGame() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::bigtwo::StartGameRequest* /*request*/, ::bigtwo::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartGame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PlayCards() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PlayCards(context, request, response); }));
    }
    ~WithRawCallbackMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayRequest* /*request*/, ::bigtwo::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayCards(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Pass() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Pass(context, request, response); }));
    }
    ~WithRawCallbackMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::bigtwo::PassRequest* /*request*/, ::bigtwo::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Pass(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetGameState() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetGameState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::bigtwo::GameStateRequest* /*request*/, ::bigtwo::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGameState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_JoinGame() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->JoinGame(context, request, response); }));
    }
    ~WithRawCallbackMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::bigtwo::JoinRequest* /*request*/, ::bigtwo::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JoinGame(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Chat() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Chat(context, request, response); }));
    }
    ~WithRawCallbackMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::bigtwo::ChatRequest* /*request*/, ::bigtwo::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Chat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartGame() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartGame(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::bigtwo::StartGameRequest* /*request*/, ::bigtwo::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartGame(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PlayCards() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::PlayRequest, ::bigtwo::PlayResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::PlayRequest, ::bigtwo::PlayResponse>* streamer) {
                       return this->StreamedPlayCards(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayRequest* /*request*/, ::bigtwo::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlayCards(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::PlayRequest,::bigtwo::PlayResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Pass() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::PassRequest, ::bigtwo::PassResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::PassRequest, ::bigtwo::PassResponse>* streamer) {
                       return this->StreamedPass(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::bigtwo::PassRequest* /*request*/, ::bigtwo::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPass(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::PassRequest,::bigtwo::PassResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGameState() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::GameStateRequest, ::bigtwo::GameStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::GameStateRequest, ::bigtwo::GameStateResponse>* streamer) {
                       return this->StreamedGetGameState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::bigtwo::GameStateRequest* /*request*/, ::bigtwo::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGameState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::GameStateRequest,::bigtwo::GameStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_JoinGame() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::JoinRequest, ::bigtwo::JoinResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::JoinRequest, ::bigtwo::JoinResponse>* streamer) {
                       return this->StreamedJoinGame(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::bigtwo::JoinRequest* /*request*/, ::bigtwo::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJoinGame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::JoinRequest,::bigtwo::JoinResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Chat() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::ChatRequest, ::bigtwo::ChatResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::ChatRequest, ::bigtwo::ChatResponse>* streamer) {
                       return this->StreamedChat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::bigtwo::ChatRequest* /*request*/, ::bigtwo::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::ChatRequest,::bigtwo::ChatResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartGame() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::StartGameRequest, ::bigtwo::StartGameResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::StartGameRequest, ::bigtwo::StartGameResponse>* streamer) {
                       return this->StreamedStartGame(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::bigtwo::StartGameRequest* /*request*/, ::bigtwo::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartGame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::StartGameRequest,::bigtwo::StartGameResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PlayCards<WithStreamedUnaryMethod_Pass<WithStreamedUnaryMethod_GetGameState<WithStreamedUnaryMethod_JoinGame<WithStreamedUnaryMethod_Chat<WithStreamedUnaryMethod_StartGame<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_PlayCards<WithStreamedUnaryMethod_Pass<WithStreamedUnaryMethod_GetGameState<WithStreamedUnaryMethod_JoinGame<WithStreamedUnaryMethod_Chat<WithStreamedUnaryMethod_StartGame<Service > > > > > > StreamedService;
};

// ----------------------------------------------------------------------------
// Table service - handles game flow
// ----------------------------------------------------------------------------
class BigTwoTableService final {
 public:
  static constexpr char const* service_full_name() {
    return "bigtwo.BigTwoTableService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Deal cards to all players
    virtual ::grpc::Status Deal(::grpc::ClientContext* context, const ::bigtwo::DealRequest& request, ::bigtwo::DealResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::DealResponse>> AsyncDeal(::grpc::ClientContext* context, const ::bigtwo::DealRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::DealResponse>>(AsyncDealRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::DealResponse>> PrepareAsyncDeal(::grpc::ClientContext* context, const ::bigtwo::DealRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::DealResponse>>(PrepareAsyncDealRaw(context, request, cq));
    }
    // Validate whether a set of cards is a legal move
    virtual ::grpc::Status ValidatePlay(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest& request, ::bigtwo::PlayValidationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayValidationResponse>> AsyncValidatePlay(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayValidationResponse>>(AsyncValidatePlayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayValidationResponse>> PrepareAsyncValidatePlay(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayValidationResponse>>(PrepareAsyncValidatePlayRaw(context, request, cq));
    }
    // Handle timeout when a player fails to move in time
    virtual ::grpc::Status HandleTimeout(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest& request, ::bigtwo::TimeoutResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::TimeoutResponse>> AsyncHandleTimeout(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::TimeoutResponse>>(AsyncHandleTimeoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::TimeoutResponse>> PrepareAsyncHandleTimeout(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::TimeoutResponse>>(PrepareAsyncHandleTimeoutRaw(context, request, cq));
    }
    // Score the game at the end of a match
    virtual ::grpc::Status Score(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest& request, ::bigtwo::ScoreResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ScoreResponse>> AsyncScore(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ScoreResponse>>(AsyncScoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ScoreResponse>> PrepareAsyncScore(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ScoreResponse>>(PrepareAsyncScoreRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Deal cards to all players
      virtual void Deal(::grpc::ClientContext* context, const ::bigtwo::DealRequest* request, ::bigtwo::DealResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Deal(::grpc::ClientContext* context, const ::bigtwo::DealRequest* request, ::bigtwo::DealResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Validate whether a set of cards is a legal move
      virtual void ValidatePlay(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest* request, ::bigtwo::PlayValidationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ValidatePlay(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest* request, ::bigtwo::PlayValidationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Handle timeout when a player fails to move in time
      virtual void HandleTimeout(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest* request, ::bigtwo::TimeoutResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HandleTimeout(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest* request, ::bigtwo::TimeoutResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Score the game at the end of a match
      virtual void Score(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest* request, ::bigtwo::ScoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Score(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest* request, ::bigtwo::ScoreResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::DealResponse>* AsyncDealRaw(::grpc::ClientContext* context, const ::bigtwo::DealRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::DealResponse>* PrepareAsyncDealRaw(::grpc::ClientContext* context, const ::bigtwo::DealRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayValidationResponse>* AsyncValidatePlayRaw(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayValidationResponse>* PrepareAsyncValidatePlayRaw(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::TimeoutResponse>* AsyncHandleTimeoutRaw(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::TimeoutResponse>* PrepareAsyncHandleTimeoutRaw(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ScoreResponse>* AsyncScoreRaw(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ScoreResponse>* PrepareAsyncScoreRaw(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Deal(::grpc::ClientContext* context, const ::bigtwo::DealRequest& request, ::bigtwo::DealResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::DealResponse>> AsyncDeal(::grpc::ClientContext* context, const ::bigtwo::DealRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::DealResponse>>(AsyncDealRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::DealResponse>> PrepareAsyncDeal(::grpc::ClientContext* context, const ::bigtwo::DealRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::DealResponse>>(PrepareAsyncDealRaw(context, request, cq));
    }
    ::grpc::Status ValidatePlay(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest& request, ::bigtwo::PlayValidationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayValidationResponse>> AsyncValidatePlay(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayValidationResponse>>(AsyncValidatePlayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayValidationResponse>> PrepareAsyncValidatePlay(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayValidationResponse>>(PrepareAsyncValidatePlayRaw(context, request, cq));
    }
    ::grpc::Status HandleTimeout(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest& request, ::bigtwo::TimeoutResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::TimeoutResponse>> AsyncHandleTimeout(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::TimeoutResponse>>(AsyncHandleTimeoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::TimeoutResponse>> PrepareAsyncHandleTimeout(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::TimeoutResponse>>(PrepareAsyncHandleTimeoutRaw(context, request, cq));
    }
    ::grpc::Status Score(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest& request, ::bigtwo::ScoreResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ScoreResponse>> AsyncScore(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ScoreResponse>>(AsyncScoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ScoreResponse>> PrepareAsyncScore(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ScoreResponse>>(PrepareAsyncScoreRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Deal(::grpc::ClientContext* context, const ::bigtwo::DealRequest* request, ::bigtwo::DealResponse* response, std::function<void(::grpc::Status)>) override;
      void Deal(::grpc::ClientContext* context, const ::bigtwo::DealRequest* request, ::bigtwo::DealResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ValidatePlay(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest* request, ::bigtwo::PlayValidationResponse* response, std::function<void(::grpc::Status)>) override;
      void ValidatePlay(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest* request, ::bigtwo::PlayValidationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HandleTimeout(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest* request, ::bigtwo::TimeoutResponse* response, std::function<void(::grpc::Status)>) override;
      void HandleTimeout(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest* request, ::bigtwo::TimeoutResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Score(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest* request, ::bigtwo::ScoreResponse* response, std::function<void(::grpc::Status)>) override;
      void Score(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest* request, ::bigtwo::ScoreResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bigtwo::DealResponse>* AsyncDealRaw(::grpc::ClientContext* context, const ::bigtwo::DealRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::DealResponse>* PrepareAsyncDealRaw(::grpc::ClientContext* context, const ::bigtwo::DealRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayValidationResponse>* AsyncValidatePlayRaw(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayValidationResponse>* PrepareAsyncValidatePlayRaw(::grpc::ClientContext* context, const ::bigtwo::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::TimeoutResponse>* AsyncHandleTimeoutRaw(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::TimeoutResponse>* PrepareAsyncHandleTimeoutRaw(::grpc::ClientContext* context, const ::bigtwo::TimeoutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::ScoreResponse>* AsyncScoreRaw(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::ScoreResponse>* PrepareAsyncScoreRaw(::grpc::ClientContext* context, const ::bigtwo::ScoreRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Deal_;
    const ::grpc::internal::RpcMethod rpcmethod_ValidatePlay_;
    const ::grpc::internal::RpcMethod rpcmethod_HandleTimeout_;
    const ::grpc::internal::RpcMethod rpcmethod_Score_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Deal cards to all players
    virtual ::grpc::Status Deal(::grpc::ServerContext* context, const ::bigtwo::DealRequest* request, ::bigtwo::DealResponse* response);
    // Validate whether a set of cards is a legal move
    virtual ::grpc::Status ValidatePlay(::grpc::ServerContext* context, const ::bigtwo::PlayValidationRequest* request, ::bigtwo::PlayValidationResponse* response);
    // Handle timeout when a player fails to move in time
    virtual ::grpc::Status HandleTimeout(::grpc::ServerContext* context, const ::bigtwo::TimeoutRequest* request, ::bigtwo::TimeoutResponse* response);
    // Score the game at the end of a match
    virtual ::grpc::Status Score(::grpc::ServerContext* context, const ::bigtwo::ScoreRequest* request, ::bigtwo::ScoreResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Deal() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::bigtwo::DealRequest* /*request*/, ::bigtwo::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeal(::grpc::ServerContext* context, ::bigtwo::DealRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::DealResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayValidationRequest* /*request*/, ::bigtwo::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidatePlay(::grpc::ServerContext* context, ::bigtwo::PlayValidationRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::PlayValidationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::bigtwo::TimeoutRequest* /*request*/, ::bigtwo::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandleTimeout(::grpc::ServerContext* context, ::bigtwo::TimeoutRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::TimeoutResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Score() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::bigtwo::ScoreRequest* /*request*/, ::bigtwo::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScore(::grpc::ServerContext* context, ::bigtwo::ScoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::ScoreResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Deal<WithAsyncMethod_ValidatePlay<WithAsyncMethod_HandleTimeout<WithAsyncMethod_Score<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Deal() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::DealRequest, ::bigtwo::DealResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::DealRequest* request, ::bigtwo::DealResponse* response) { return this->Deal(context, request, response); }));}
    void SetMessageAllocatorFor_Deal(
        ::grpc::MessageAllocator< ::bigtwo::DealRequest, ::bigtwo::DealResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::DealRequest, ::bigtwo::DealResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::bigtwo::DealRequest* /*request*/, ::bigtwo::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Deal(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::DealRequest* /*request*/, ::bigtwo::DealResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::PlayValidationRequest, ::bigtwo::PlayValidationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::PlayValidationRequest* request, ::bigtwo::PlayValidationResponse* response) { return this->ValidatePlay(context, request, response); }));}
    void SetMessageAllocatorFor_ValidatePlay(
        ::grpc::MessageAllocator< ::bigtwo::PlayValidationRequest, ::bigtwo::PlayValidationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::PlayValidationRequest, ::bigtwo::PlayValidationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayValidationRequest* /*request*/, ::bigtwo::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ValidatePlay(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::PlayValidationRequest* /*request*/, ::bigtwo::PlayValidationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::TimeoutRequest, ::bigtwo::TimeoutResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::TimeoutRequest* request, ::bigtwo::TimeoutResponse* response) { return this->HandleTimeout(context, request, response); }));}
    void SetMessageAllocatorFor_HandleTimeout(
        ::grpc::MessageAllocator< ::bigtwo::TimeoutRequest, ::bigtwo::TimeoutResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::TimeoutRequest, ::bigtwo::TimeoutResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::bigtwo::TimeoutRequest* /*request*/, ::bigtwo::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HandleTimeout(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::TimeoutRequest* /*request*/, ::bigtwo::TimeoutResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Score() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::ScoreRequest, ::bigtwo::ScoreResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::ScoreRequest* request, ::bigtwo::ScoreResponse* response) { return this->Score(context, request, response); }));}
    void SetMessageAllocatorFor_Score(
        ::grpc::MessageAllocator< ::bigtwo::ScoreRequest, ::bigtwo::ScoreResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::ScoreRequest, ::bigtwo::ScoreResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::bigtwo::ScoreRequest* /*request*/, ::bigtwo::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Score(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::ScoreRequest* /*request*/, ::bigtwo::ScoreResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Deal<WithCallbackMethod_ValidatePlay<WithCallbackMethod_HandleTimeout<WithCallbackMethod_Score<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Deal() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::bigtwo::DealRequest* /*request*/, ::bigtwo::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayValidationRequest* /*request*/, ::bigtwo::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::bigtwo::TimeoutRequest* /*request*/, ::bigtwo::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Score() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::bigtwo::ScoreRequest* /*request*/, ::bigtwo::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Deal() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::bigtwo::DealRequest* /*request*/, ::bigtwo::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeal(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayValidationRequest* /*request*/, ::bigtwo::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidatePlay(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::bigtwo::TimeoutRequest* /*request*/, ::bigtwo::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandleTimeout(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Score() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::bigtwo::ScoreRequest* /*request*/, ::bigtwo::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Deal() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Deal(context, request, response); }));
    }
    ~WithRawCallbackMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::bigtwo::DealRequest* /*request*/, ::bigtwo::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Deal(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ValidatePlay(context, request, response); }));
    }
    ~WithRawCallbackMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayValidationRequest* /*request*/, ::bigtwo::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ValidatePlay(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HandleTimeout(context, request, response); }));
    }
    ~WithRawCallbackMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::bigtwo::TimeoutRequest* /*request*/, ::bigtwo::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HandleTimeout(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Score() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Score(context, request, response); }));
    }
    ~WithRawCallbackMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::bigtwo::ScoreRequest* /*request*/, ::bigtwo::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Score(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Deal() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::DealRequest, ::bigtwo::DealResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::DealRequest, ::bigtwo::DealResponse>* streamer) {
                       return this->StreamedDeal(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::bigtwo::DealRequest* /*request*/, ::bigtwo::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeal(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::DealRequest,::bigtwo::DealResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::PlayValidationRequest, ::bigtwo::PlayValidationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::PlayValidationRequest, ::bigtwo::PlayValidationResponse>* streamer) {
                       return this->StreamedValidatePlay(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayValidationRequest* /*request*/, ::bigtwo::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedValidatePlay(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::PlayValidationRequest,::bigtwo::PlayValidationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::TimeoutRequest, ::bigtwo::TimeoutResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::TimeoutRequest, ::bigtwo::TimeoutResponse>* streamer) {
                       return this->StreamedHandleTimeout(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::bigtwo::TimeoutRequest* /*request*/, ::bigtwo::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHandleTimeout(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::TimeoutRequest,::bigtwo::TimeoutResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Score() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::ScoreRequest, ::bigtwo::ScoreResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::ScoreRequest, ::bigtwo::ScoreResponse>* streamer) {
                       return this->StreamedScore(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::bigtwo::ScoreRequest* /*request*/, ::bigtwo::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedScore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::ScoreRequest,::bigtwo::ScoreResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Deal<WithStreamedUnaryMethod_ValidatePlay<WithStreamedUnaryMethod_HandleTimeout<WithStreamedUnaryMethod_Score<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Deal<WithStreamedUnaryMethod_ValidatePlay<WithStreamedUnaryMethod_HandleTimeout<WithStreamedUnaryMethod_Score<Service > > > > StreamedService;
};

// ---------------------------------------------------------------------------
// 後台管理功能
// ---------------------------------------------------------------------------
class BigTwoManagementService final {
 public:
  static constexpr char const* service_full_name() {
    return "bigtwo.BigTwoManagementService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetRanking(::grpc::ClientContext* context, const ::bigtwo::RankingRequest& request, ::bigtwo::RankingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::RankingResponse>> AsyncGetRanking(::grpc::ClientContext* context, const ::bigtwo::RankingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::RankingResponse>>(AsyncGetRankingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::RankingResponse>> PrepareAsyncGetRanking(::grpc::ClientContext* context, const ::bigtwo::RankingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::RankingResponse>>(PrepareAsyncGetRankingRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPlayerWinRate(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest& request, ::bigtwo::PlayerRateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayerRateResponse>> AsyncGetPlayerWinRate(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayerRateResponse>>(AsyncGetPlayerWinRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayerRateResponse>> PrepareAsyncGetPlayerWinRate(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayerRateResponse>>(PrepareAsyncGetPlayerWinRateRaw(context, request, cq));
    }
    virtual ::grpc::Status GetActivityLog(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest& request, ::bigtwo::ActivityLogResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ActivityLogResponse>> AsyncGetActivityLog(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ActivityLogResponse>>(AsyncGetActivityLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ActivityLogResponse>> PrepareAsyncGetActivityLog(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ActivityLogResponse>>(PrepareAsyncGetActivityLogRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void GetRanking(::grpc::ClientContext* context, const ::bigtwo::RankingRequest* request, ::bigtwo::RankingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRanking(::grpc::ClientContext* context, const ::bigtwo::RankingRequest* request, ::bigtwo::RankingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPlayerWinRate(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest* request, ::bigtwo::PlayerRateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPlayerWinRate(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest* request, ::bigtwo::PlayerRateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetActivityLog(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest* request, ::bigtwo::ActivityLogResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetActivityLog(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest* request, ::bigtwo::ActivityLogResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::RankingResponse>* AsyncGetRankingRaw(::grpc::ClientContext* context, const ::bigtwo::RankingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::RankingResponse>* PrepareAsyncGetRankingRaw(::grpc::ClientContext* context, const ::bigtwo::RankingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayerRateResponse>* AsyncGetPlayerWinRateRaw(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::PlayerRateResponse>* PrepareAsyncGetPlayerWinRateRaw(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ActivityLogResponse>* AsyncGetActivityLogRaw(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::bigtwo::ActivityLogResponse>* PrepareAsyncGetActivityLogRaw(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetRanking(::grpc::ClientContext* context, const ::bigtwo::RankingRequest& request, ::bigtwo::RankingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::RankingResponse>> AsyncGetRanking(::grpc::ClientContext* context, const ::bigtwo::RankingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::RankingResponse>>(AsyncGetRankingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::RankingResponse>> PrepareAsyncGetRanking(::grpc::ClientContext* context, const ::bigtwo::RankingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::RankingResponse>>(PrepareAsyncGetRankingRaw(context, request, cq));
    }
    ::grpc::Status GetPlayerWinRate(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest& request, ::bigtwo::PlayerRateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayerRateResponse>> AsyncGetPlayerWinRate(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayerRateResponse>>(AsyncGetPlayerWinRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayerRateResponse>> PrepareAsyncGetPlayerWinRate(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayerRateResponse>>(PrepareAsyncGetPlayerWinRateRaw(context, request, cq));
    }
    ::grpc::Status GetActivityLog(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest& request, ::bigtwo::ActivityLogResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ActivityLogResponse>> AsyncGetActivityLog(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ActivityLogResponse>>(AsyncGetActivityLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ActivityLogResponse>> PrepareAsyncGetActivityLog(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::bigtwo::ActivityLogResponse>>(PrepareAsyncGetActivityLogRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetRanking(::grpc::ClientContext* context, const ::bigtwo::RankingRequest* request, ::bigtwo::RankingResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRanking(::grpc::ClientContext* context, const ::bigtwo::RankingRequest* request, ::bigtwo::RankingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPlayerWinRate(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest* request, ::bigtwo::PlayerRateResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPlayerWinRate(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest* request, ::bigtwo::PlayerRateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetActivityLog(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest* request, ::bigtwo::ActivityLogResponse* response, std::function<void(::grpc::Status)>) override;
      void GetActivityLog(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest* request, ::bigtwo::ActivityLogResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::bigtwo::RankingResponse>* AsyncGetRankingRaw(::grpc::ClientContext* context, const ::bigtwo::RankingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::RankingResponse>* PrepareAsyncGetRankingRaw(::grpc::ClientContext* context, const ::bigtwo::RankingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayerRateResponse>* AsyncGetPlayerWinRateRaw(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::PlayerRateResponse>* PrepareAsyncGetPlayerWinRateRaw(::grpc::ClientContext* context, const ::bigtwo::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::ActivityLogResponse>* AsyncGetActivityLogRaw(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::bigtwo::ActivityLogResponse>* PrepareAsyncGetActivityLogRaw(::grpc::ClientContext* context, const ::bigtwo::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetRanking_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPlayerWinRate_;
    const ::grpc::internal::RpcMethod rpcmethod_GetActivityLog_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetRanking(::grpc::ServerContext* context, const ::bigtwo::RankingRequest* request, ::bigtwo::RankingResponse* response);
    virtual ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* context, const ::bigtwo::PlayerRateRequest* request, ::bigtwo::PlayerRateResponse* response);
    virtual ::grpc::Status GetActivityLog(::grpc::ServerContext* context, const ::bigtwo::ActivityLogRequest* request, ::bigtwo::ActivityLogResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRanking() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::bigtwo::RankingRequest* /*request*/, ::bigtwo::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRanking(::grpc::ServerContext* context, ::bigtwo::RankingRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::RankingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayerRateRequest* /*request*/, ::bigtwo::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerWinRate(::grpc::ServerContext* context, ::bigtwo::PlayerRateRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::PlayerRateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::bigtwo::ActivityLogRequest* /*request*/, ::bigtwo::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActivityLog(::grpc::ServerContext* context, ::bigtwo::ActivityLogRequest* request, ::grpc::ServerAsyncResponseWriter< ::bigtwo::ActivityLogResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetRanking<WithAsyncMethod_GetPlayerWinRate<WithAsyncMethod_GetActivityLog<Service > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRanking() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::RankingRequest, ::bigtwo::RankingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::RankingRequest* request, ::bigtwo::RankingResponse* response) { return this->GetRanking(context, request, response); }));}
    void SetMessageAllocatorFor_GetRanking(
        ::grpc::MessageAllocator< ::bigtwo::RankingRequest, ::bigtwo::RankingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::RankingRequest, ::bigtwo::RankingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::bigtwo::RankingRequest* /*request*/, ::bigtwo::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRanking(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::RankingRequest* /*request*/, ::bigtwo::RankingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::PlayerRateRequest, ::bigtwo::PlayerRateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::PlayerRateRequest* request, ::bigtwo::PlayerRateResponse* response) { return this->GetPlayerWinRate(context, request, response); }));}
    void SetMessageAllocatorFor_GetPlayerWinRate(
        ::grpc::MessageAllocator< ::bigtwo::PlayerRateRequest, ::bigtwo::PlayerRateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::PlayerRateRequest, ::bigtwo::PlayerRateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayerRateRequest* /*request*/, ::bigtwo::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPlayerWinRate(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::PlayerRateRequest* /*request*/, ::bigtwo::PlayerRateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::bigtwo::ActivityLogRequest, ::bigtwo::ActivityLogResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::bigtwo::ActivityLogRequest* request, ::bigtwo::ActivityLogResponse* response) { return this->GetActivityLog(context, request, response); }));}
    void SetMessageAllocatorFor_GetActivityLog(
        ::grpc::MessageAllocator< ::bigtwo::ActivityLogRequest, ::bigtwo::ActivityLogResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::bigtwo::ActivityLogRequest, ::bigtwo::ActivityLogResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::bigtwo::ActivityLogRequest* /*request*/, ::bigtwo::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetActivityLog(
      ::grpc::CallbackServerContext* /*context*/, const ::bigtwo::ActivityLogRequest* /*request*/, ::bigtwo::ActivityLogResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetRanking<WithCallbackMethod_GetPlayerWinRate<WithCallbackMethod_GetActivityLog<Service > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRanking() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::bigtwo::RankingRequest* /*request*/, ::bigtwo::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayerRateRequest* /*request*/, ::bigtwo::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::bigtwo::ActivityLogRequest* /*request*/, ::bigtwo::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRanking() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::bigtwo::RankingRequest* /*request*/, ::bigtwo::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRanking(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayerRateRequest* /*request*/, ::bigtwo::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerWinRate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::bigtwo::ActivityLogRequest* /*request*/, ::bigtwo::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActivityLog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRanking() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRanking(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::bigtwo::RankingRequest* /*request*/, ::bigtwo::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRanking(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPlayerWinRate(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayerRateRequest* /*request*/, ::bigtwo::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPlayerWinRate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetActivityLog(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::bigtwo::ActivityLogRequest* /*request*/, ::bigtwo::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetActivityLog(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRanking() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::RankingRequest, ::bigtwo::RankingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::RankingRequest, ::bigtwo::RankingResponse>* streamer) {
                       return this->StreamedGetRanking(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::bigtwo::RankingRequest* /*request*/, ::bigtwo::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRanking(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::RankingRequest,::bigtwo::RankingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::PlayerRateRequest, ::bigtwo::PlayerRateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::PlayerRateRequest, ::bigtwo::PlayerRateResponse>* streamer) {
                       return this->StreamedGetPlayerWinRate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::bigtwo::PlayerRateRequest* /*request*/, ::bigtwo::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPlayerWinRate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::PlayerRateRequest,::bigtwo::PlayerRateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::bigtwo::ActivityLogRequest, ::bigtwo::ActivityLogResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::bigtwo::ActivityLogRequest, ::bigtwo::ActivityLogResponse>* streamer) {
                       return this->StreamedGetActivityLog(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::bigtwo::ActivityLogRequest* /*request*/, ::bigtwo::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetActivityLog(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::bigtwo::ActivityLogRequest,::bigtwo::ActivityLogResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetRanking<WithStreamedUnaryMethod_GetPlayerWinRate<WithStreamedUnaryMethod_GetActivityLog<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetRanking<WithStreamedUnaryMethod_GetPlayerWinRate<WithStreamedUnaryMethod_GetActivityLog<Service > > > StreamedService;
};

}  // namespace bigtwo


#endif  // GRPC_bigtwo_2eproto__INCLUDED
