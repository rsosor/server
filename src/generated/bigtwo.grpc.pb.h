// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: bigtwo.proto
#ifndef GRPC_bigtwo_2eproto__INCLUDED
#define GRPC_bigtwo_2eproto__INCLUDED

#include "bigtwo.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace rsosor {
namespace generated {

// ---------------------------------------------------------------------------
// 前台遊戲主要功能
// ---------------------------------------------------------------------------
class BigTwoService final {
 public:
  static constexpr char const* service_full_name() {
    return "rsosor.generated.BigTwoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status PlayCards(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest& request, ::rsosor::generated::PlayResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayResponse>> AsyncPlayCards(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayResponse>>(AsyncPlayCardsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayResponse>> PrepareAsyncPlayCards(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayResponse>>(PrepareAsyncPlayCardsRaw(context, request, cq));
    }
    virtual ::grpc::Status Pass(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest& request, ::rsosor::generated::PassResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PassResponse>> AsyncPass(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PassResponse>>(AsyncPassRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PassResponse>> PrepareAsyncPass(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PassResponse>>(PrepareAsyncPassRaw(context, request, cq));
    }
    virtual ::grpc::Status GetGameState(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest& request, ::rsosor::generated::GameStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::GameStateResponse>> AsyncGetGameState(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::GameStateResponse>>(AsyncGetGameStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::GameStateResponse>> PrepareAsyncGetGameState(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::GameStateResponse>>(PrepareAsyncGetGameStateRaw(context, request, cq));
    }
    virtual ::grpc::Status JoinGame(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest& request, ::rsosor::generated::JoinResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::JoinResponse>> AsyncJoinGame(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::JoinResponse>>(AsyncJoinGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::JoinResponse>> PrepareAsyncJoinGame(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::JoinResponse>>(PrepareAsyncJoinGameRaw(context, request, cq));
    }
    virtual ::grpc::Status Chat(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest& request, ::rsosor::generated::ChatResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ChatResponse>> AsyncChat(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ChatResponse>>(AsyncChatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ChatResponse>> PrepareAsyncChat(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ChatResponse>>(PrepareAsyncChatRaw(context, request, cq));
    }
    // 新增：可以由遊戲主持人/server 觸發遊戲開始
    virtual ::grpc::Status StartGame(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest& request, ::rsosor::generated::StartGameResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::StartGameResponse>> AsyncStartGame(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::StartGameResponse>>(AsyncStartGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::StartGameResponse>> PrepareAsyncStartGame(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::StartGameResponse>>(PrepareAsyncStartGameRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void PlayCards(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest* request, ::rsosor::generated::PlayResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PlayCards(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest* request, ::rsosor::generated::PlayResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Pass(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest* request, ::rsosor::generated::PassResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Pass(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest* request, ::rsosor::generated::PassResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetGameState(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest* request, ::rsosor::generated::GameStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGameState(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest* request, ::rsosor::generated::GameStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void JoinGame(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest* request, ::rsosor::generated::JoinResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void JoinGame(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest* request, ::rsosor::generated::JoinResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Chat(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest* request, ::rsosor::generated::ChatResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Chat(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest* request, ::rsosor::generated::ChatResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 新增：可以由遊戲主持人/server 觸發遊戲開始
      virtual void StartGame(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest* request, ::rsosor::generated::StartGameResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartGame(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest* request, ::rsosor::generated::StartGameResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayResponse>* AsyncPlayCardsRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayResponse>* PrepareAsyncPlayCardsRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PassResponse>* AsyncPassRaw(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PassResponse>* PrepareAsyncPassRaw(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::GameStateResponse>* AsyncGetGameStateRaw(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::GameStateResponse>* PrepareAsyncGetGameStateRaw(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::JoinResponse>* AsyncJoinGameRaw(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::JoinResponse>* PrepareAsyncJoinGameRaw(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ChatResponse>* AsyncChatRaw(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ChatResponse>* PrepareAsyncChatRaw(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::StartGameResponse>* AsyncStartGameRaw(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::StartGameResponse>* PrepareAsyncStartGameRaw(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status PlayCards(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest& request, ::rsosor::generated::PlayResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayResponse>> AsyncPlayCards(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayResponse>>(AsyncPlayCardsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayResponse>> PrepareAsyncPlayCards(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayResponse>>(PrepareAsyncPlayCardsRaw(context, request, cq));
    }
    ::grpc::Status Pass(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest& request, ::rsosor::generated::PassResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PassResponse>> AsyncPass(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PassResponse>>(AsyncPassRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PassResponse>> PrepareAsyncPass(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PassResponse>>(PrepareAsyncPassRaw(context, request, cq));
    }
    ::grpc::Status GetGameState(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest& request, ::rsosor::generated::GameStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::GameStateResponse>> AsyncGetGameState(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::GameStateResponse>>(AsyncGetGameStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::GameStateResponse>> PrepareAsyncGetGameState(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::GameStateResponse>>(PrepareAsyncGetGameStateRaw(context, request, cq));
    }
    ::grpc::Status JoinGame(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest& request, ::rsosor::generated::JoinResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::JoinResponse>> AsyncJoinGame(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::JoinResponse>>(AsyncJoinGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::JoinResponse>> PrepareAsyncJoinGame(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::JoinResponse>>(PrepareAsyncJoinGameRaw(context, request, cq));
    }
    ::grpc::Status Chat(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest& request, ::rsosor::generated::ChatResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ChatResponse>> AsyncChat(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ChatResponse>>(AsyncChatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ChatResponse>> PrepareAsyncChat(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ChatResponse>>(PrepareAsyncChatRaw(context, request, cq));
    }
    ::grpc::Status StartGame(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest& request, ::rsosor::generated::StartGameResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::StartGameResponse>> AsyncStartGame(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::StartGameResponse>>(AsyncStartGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::StartGameResponse>> PrepareAsyncStartGame(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::StartGameResponse>>(PrepareAsyncStartGameRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void PlayCards(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest* request, ::rsosor::generated::PlayResponse* response, std::function<void(::grpc::Status)>) override;
      void PlayCards(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest* request, ::rsosor::generated::PlayResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Pass(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest* request, ::rsosor::generated::PassResponse* response, std::function<void(::grpc::Status)>) override;
      void Pass(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest* request, ::rsosor::generated::PassResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetGameState(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest* request, ::rsosor::generated::GameStateResponse* response, std::function<void(::grpc::Status)>) override;
      void GetGameState(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest* request, ::rsosor::generated::GameStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void JoinGame(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest* request, ::rsosor::generated::JoinResponse* response, std::function<void(::grpc::Status)>) override;
      void JoinGame(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest* request, ::rsosor::generated::JoinResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Chat(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest* request, ::rsosor::generated::ChatResponse* response, std::function<void(::grpc::Status)>) override;
      void Chat(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest* request, ::rsosor::generated::ChatResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StartGame(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest* request, ::rsosor::generated::StartGameResponse* response, std::function<void(::grpc::Status)>) override;
      void StartGame(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest* request, ::rsosor::generated::StartGameResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayResponse>* AsyncPlayCardsRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayResponse>* PrepareAsyncPlayCardsRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PassResponse>* AsyncPassRaw(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PassResponse>* PrepareAsyncPassRaw(::grpc::ClientContext* context, const ::rsosor::generated::PassRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::GameStateResponse>* AsyncGetGameStateRaw(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::GameStateResponse>* PrepareAsyncGetGameStateRaw(::grpc::ClientContext* context, const ::rsosor::generated::GameStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::JoinResponse>* AsyncJoinGameRaw(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::JoinResponse>* PrepareAsyncJoinGameRaw(::grpc::ClientContext* context, const ::rsosor::generated::JoinRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ChatResponse>* AsyncChatRaw(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ChatResponse>* PrepareAsyncChatRaw(::grpc::ClientContext* context, const ::rsosor::generated::ChatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::StartGameResponse>* AsyncStartGameRaw(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::StartGameResponse>* PrepareAsyncStartGameRaw(::grpc::ClientContext* context, const ::rsosor::generated::StartGameRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PlayCards_;
    const ::grpc::internal::RpcMethod rpcmethod_Pass_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGameState_;
    const ::grpc::internal::RpcMethod rpcmethod_JoinGame_;
    const ::grpc::internal::RpcMethod rpcmethod_Chat_;
    const ::grpc::internal::RpcMethod rpcmethod_StartGame_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status PlayCards(::grpc::ServerContext* context, const ::rsosor::generated::PlayRequest* request, ::rsosor::generated::PlayResponse* response);
    virtual ::grpc::Status Pass(::grpc::ServerContext* context, const ::rsosor::generated::PassRequest* request, ::rsosor::generated::PassResponse* response);
    virtual ::grpc::Status GetGameState(::grpc::ServerContext* context, const ::rsosor::generated::GameStateRequest* request, ::rsosor::generated::GameStateResponse* response);
    virtual ::grpc::Status JoinGame(::grpc::ServerContext* context, const ::rsosor::generated::JoinRequest* request, ::rsosor::generated::JoinResponse* response);
    virtual ::grpc::Status Chat(::grpc::ServerContext* context, const ::rsosor::generated::ChatRequest* request, ::rsosor::generated::ChatResponse* response);
    // 新增：可以由遊戲主持人/server 觸發遊戲開始
    virtual ::grpc::Status StartGame(::grpc::ServerContext* context, const ::rsosor::generated::StartGameRequest* request, ::rsosor::generated::StartGameResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PlayCards() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayRequest* /*request*/, ::rsosor::generated::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayCards(::grpc::ServerContext* context, ::rsosor::generated::PlayRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::PlayResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Pass() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PassRequest* /*request*/, ::rsosor::generated::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPass(::grpc::ServerContext* context, ::rsosor::generated::PassRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::PassResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGameState() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::rsosor::generated::GameStateRequest* /*request*/, ::rsosor::generated::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGameState(::grpc::ServerContext* context, ::rsosor::generated::GameStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::GameStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JoinGame() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::JoinRequest* /*request*/, ::rsosor::generated::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoinGame(::grpc::ServerContext* context, ::rsosor::generated::JoinRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::JoinResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Chat() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ChatRequest* /*request*/, ::rsosor::generated::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChat(::grpc::ServerContext* context, ::rsosor::generated::ChatRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::ChatResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartGame() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::StartGameRequest* /*request*/, ::rsosor::generated::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartGame(::grpc::ServerContext* context, ::rsosor::generated::StartGameRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::StartGameResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PlayCards<WithAsyncMethod_Pass<WithAsyncMethod_GetGameState<WithAsyncMethod_JoinGame<WithAsyncMethod_Chat<WithAsyncMethod_StartGame<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PlayCards() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::PlayRequest, ::rsosor::generated::PlayResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::PlayRequest* request, ::rsosor::generated::PlayResponse* response) { return this->PlayCards(context, request, response); }));}
    void SetMessageAllocatorFor_PlayCards(
        ::grpc::MessageAllocator< ::rsosor::generated::PlayRequest, ::rsosor::generated::PlayResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::PlayRequest, ::rsosor::generated::PlayResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayRequest* /*request*/, ::rsosor::generated::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayCards(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::PlayRequest* /*request*/, ::rsosor::generated::PlayResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Pass() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::PassRequest, ::rsosor::generated::PassResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::PassRequest* request, ::rsosor::generated::PassResponse* response) { return this->Pass(context, request, response); }));}
    void SetMessageAllocatorFor_Pass(
        ::grpc::MessageAllocator< ::rsosor::generated::PassRequest, ::rsosor::generated::PassResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::PassRequest, ::rsosor::generated::PassResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PassRequest* /*request*/, ::rsosor::generated::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Pass(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::PassRequest* /*request*/, ::rsosor::generated::PassResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetGameState() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::GameStateRequest, ::rsosor::generated::GameStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::GameStateRequest* request, ::rsosor::generated::GameStateResponse* response) { return this->GetGameState(context, request, response); }));}
    void SetMessageAllocatorFor_GetGameState(
        ::grpc::MessageAllocator< ::rsosor::generated::GameStateRequest, ::rsosor::generated::GameStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::GameStateRequest, ::rsosor::generated::GameStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::rsosor::generated::GameStateRequest* /*request*/, ::rsosor::generated::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGameState(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::GameStateRequest* /*request*/, ::rsosor::generated::GameStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_JoinGame() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::JoinRequest, ::rsosor::generated::JoinResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::JoinRequest* request, ::rsosor::generated::JoinResponse* response) { return this->JoinGame(context, request, response); }));}
    void SetMessageAllocatorFor_JoinGame(
        ::grpc::MessageAllocator< ::rsosor::generated::JoinRequest, ::rsosor::generated::JoinResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::JoinRequest, ::rsosor::generated::JoinResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::JoinRequest* /*request*/, ::rsosor::generated::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JoinGame(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::JoinRequest* /*request*/, ::rsosor::generated::JoinResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Chat() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::ChatRequest, ::rsosor::generated::ChatResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::ChatRequest* request, ::rsosor::generated::ChatResponse* response) { return this->Chat(context, request, response); }));}
    void SetMessageAllocatorFor_Chat(
        ::grpc::MessageAllocator< ::rsosor::generated::ChatRequest, ::rsosor::generated::ChatResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::ChatRequest, ::rsosor::generated::ChatResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ChatRequest* /*request*/, ::rsosor::generated::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Chat(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::ChatRequest* /*request*/, ::rsosor::generated::ChatResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartGame() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::StartGameRequest, ::rsosor::generated::StartGameResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::StartGameRequest* request, ::rsosor::generated::StartGameResponse* response) { return this->StartGame(context, request, response); }));}
    void SetMessageAllocatorFor_StartGame(
        ::grpc::MessageAllocator< ::rsosor::generated::StartGameRequest, ::rsosor::generated::StartGameResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::StartGameRequest, ::rsosor::generated::StartGameResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::StartGameRequest* /*request*/, ::rsosor::generated::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartGame(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::StartGameRequest* /*request*/, ::rsosor::generated::StartGameResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_PlayCards<WithCallbackMethod_Pass<WithCallbackMethod_GetGameState<WithCallbackMethod_JoinGame<WithCallbackMethod_Chat<WithCallbackMethod_StartGame<Service > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PlayCards() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayRequest* /*request*/, ::rsosor::generated::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Pass() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PassRequest* /*request*/, ::rsosor::generated::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGameState() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::rsosor::generated::GameStateRequest* /*request*/, ::rsosor::generated::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JoinGame() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::JoinRequest* /*request*/, ::rsosor::generated::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Chat() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ChatRequest* /*request*/, ::rsosor::generated::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartGame() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::StartGameRequest* /*request*/, ::rsosor::generated::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PlayCards() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayRequest* /*request*/, ::rsosor::generated::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPlayCards(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Pass() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PassRequest* /*request*/, ::rsosor::generated::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPass(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGameState() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::rsosor::generated::GameStateRequest* /*request*/, ::rsosor::generated::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGameState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JoinGame() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::JoinRequest* /*request*/, ::rsosor::generated::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoinGame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Chat() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ChatRequest* /*request*/, ::rsosor::generated::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartGame() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::StartGameRequest* /*request*/, ::rsosor::generated::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartGame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PlayCards() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PlayCards(context, request, response); }));
    }
    ~WithRawCallbackMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayRequest* /*request*/, ::rsosor::generated::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PlayCards(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Pass() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Pass(context, request, response); }));
    }
    ~WithRawCallbackMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PassRequest* /*request*/, ::rsosor::generated::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Pass(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetGameState() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetGameState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::rsosor::generated::GameStateRequest* /*request*/, ::rsosor::generated::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetGameState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_JoinGame() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->JoinGame(context, request, response); }));
    }
    ~WithRawCallbackMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::JoinRequest* /*request*/, ::rsosor::generated::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* JoinGame(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Chat() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Chat(context, request, response); }));
    }
    ~WithRawCallbackMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ChatRequest* /*request*/, ::rsosor::generated::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Chat(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartGame() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartGame(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::StartGameRequest* /*request*/, ::rsosor::generated::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartGame(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PlayCards : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PlayCards() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::PlayRequest, ::rsosor::generated::PlayResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::PlayRequest, ::rsosor::generated::PlayResponse>* streamer) {
                       return this->StreamedPlayCards(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PlayCards() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PlayCards(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayRequest* /*request*/, ::rsosor::generated::PlayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPlayCards(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::PlayRequest,::rsosor::generated::PlayResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Pass : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Pass() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::PassRequest, ::rsosor::generated::PassResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::PassRequest, ::rsosor::generated::PassResponse>* streamer) {
                       return this->StreamedPass(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Pass() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Pass(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PassRequest* /*request*/, ::rsosor::generated::PassResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPass(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::PassRequest,::rsosor::generated::PassResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGameState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGameState() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::GameStateRequest, ::rsosor::generated::GameStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::GameStateRequest, ::rsosor::generated::GameStateResponse>* streamer) {
                       return this->StreamedGetGameState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetGameState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGameState(::grpc::ServerContext* /*context*/, const ::rsosor::generated::GameStateRequest* /*request*/, ::rsosor::generated::GameStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGameState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::GameStateRequest,::rsosor::generated::GameStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_JoinGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_JoinGame() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::JoinRequest, ::rsosor::generated::JoinResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::JoinRequest, ::rsosor::generated::JoinResponse>* streamer) {
                       return this->StreamedJoinGame(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_JoinGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JoinGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::JoinRequest* /*request*/, ::rsosor::generated::JoinResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJoinGame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::JoinRequest,::rsosor::generated::JoinResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Chat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Chat() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::ChatRequest, ::rsosor::generated::ChatResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::ChatRequest, ::rsosor::generated::ChatResponse>* streamer) {
                       return this->StreamedChat(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Chat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Chat(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ChatRequest* /*request*/, ::rsosor::generated::ChatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::ChatRequest,::rsosor::generated::ChatResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartGame() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::StartGameRequest, ::rsosor::generated::StartGameResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::StartGameRequest, ::rsosor::generated::StartGameResponse>* streamer) {
                       return this->StreamedStartGame(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartGame(::grpc::ServerContext* /*context*/, const ::rsosor::generated::StartGameRequest* /*request*/, ::rsosor::generated::StartGameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartGame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::StartGameRequest,::rsosor::generated::StartGameResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PlayCards<WithStreamedUnaryMethod_Pass<WithStreamedUnaryMethod_GetGameState<WithStreamedUnaryMethod_JoinGame<WithStreamedUnaryMethod_Chat<WithStreamedUnaryMethod_StartGame<Service > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_PlayCards<WithStreamedUnaryMethod_Pass<WithStreamedUnaryMethod_GetGameState<WithStreamedUnaryMethod_JoinGame<WithStreamedUnaryMethod_Chat<WithStreamedUnaryMethod_StartGame<Service > > > > > > StreamedService;
};

// ----------------------------------------------------------------------------
// Table service - handles game flow
// ----------------------------------------------------------------------------
class BigTwoTableService final {
 public:
  static constexpr char const* service_full_name() {
    return "rsosor.generated.BigTwoTableService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Deal cards to all players
    virtual ::grpc::Status Deal(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest& request, ::rsosor::generated::DealResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::DealResponse>> AsyncDeal(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::DealResponse>>(AsyncDealRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::DealResponse>> PrepareAsyncDeal(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::DealResponse>>(PrepareAsyncDealRaw(context, request, cq));
    }
    // Validate whether a set of cards is a legal move
    virtual ::grpc::Status ValidatePlay(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest& request, ::rsosor::generated::PlayValidationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayValidationResponse>> AsyncValidatePlay(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayValidationResponse>>(AsyncValidatePlayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayValidationResponse>> PrepareAsyncValidatePlay(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayValidationResponse>>(PrepareAsyncValidatePlayRaw(context, request, cq));
    }
    // Handle timeout when a player fails to move in time
    virtual ::grpc::Status HandleTimeout(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest& request, ::rsosor::generated::TimeoutResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::TimeoutResponse>> AsyncHandleTimeout(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::TimeoutResponse>>(AsyncHandleTimeoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::TimeoutResponse>> PrepareAsyncHandleTimeout(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::TimeoutResponse>>(PrepareAsyncHandleTimeoutRaw(context, request, cq));
    }
    // Score the game at the end of a match
    virtual ::grpc::Status Score(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest& request, ::rsosor::generated::ScoreResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ScoreResponse>> AsyncScore(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ScoreResponse>>(AsyncScoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ScoreResponse>> PrepareAsyncScore(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ScoreResponse>>(PrepareAsyncScoreRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Deal cards to all players
      virtual void Deal(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest* request, ::rsosor::generated::DealResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Deal(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest* request, ::rsosor::generated::DealResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Validate whether a set of cards is a legal move
      virtual void ValidatePlay(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest* request, ::rsosor::generated::PlayValidationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ValidatePlay(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest* request, ::rsosor::generated::PlayValidationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Handle timeout when a player fails to move in time
      virtual void HandleTimeout(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest* request, ::rsosor::generated::TimeoutResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HandleTimeout(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest* request, ::rsosor::generated::TimeoutResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Score the game at the end of a match
      virtual void Score(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest* request, ::rsosor::generated::ScoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Score(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest* request, ::rsosor::generated::ScoreResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::DealResponse>* AsyncDealRaw(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::DealResponse>* PrepareAsyncDealRaw(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayValidationResponse>* AsyncValidatePlayRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayValidationResponse>* PrepareAsyncValidatePlayRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::TimeoutResponse>* AsyncHandleTimeoutRaw(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::TimeoutResponse>* PrepareAsyncHandleTimeoutRaw(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ScoreResponse>* AsyncScoreRaw(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ScoreResponse>* PrepareAsyncScoreRaw(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Deal(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest& request, ::rsosor::generated::DealResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::DealResponse>> AsyncDeal(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::DealResponse>>(AsyncDealRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::DealResponse>> PrepareAsyncDeal(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::DealResponse>>(PrepareAsyncDealRaw(context, request, cq));
    }
    ::grpc::Status ValidatePlay(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest& request, ::rsosor::generated::PlayValidationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayValidationResponse>> AsyncValidatePlay(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayValidationResponse>>(AsyncValidatePlayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayValidationResponse>> PrepareAsyncValidatePlay(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayValidationResponse>>(PrepareAsyncValidatePlayRaw(context, request, cq));
    }
    ::grpc::Status HandleTimeout(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest& request, ::rsosor::generated::TimeoutResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::TimeoutResponse>> AsyncHandleTimeout(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::TimeoutResponse>>(AsyncHandleTimeoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::TimeoutResponse>> PrepareAsyncHandleTimeout(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::TimeoutResponse>>(PrepareAsyncHandleTimeoutRaw(context, request, cq));
    }
    ::grpc::Status Score(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest& request, ::rsosor::generated::ScoreResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ScoreResponse>> AsyncScore(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ScoreResponse>>(AsyncScoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ScoreResponse>> PrepareAsyncScore(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ScoreResponse>>(PrepareAsyncScoreRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Deal(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest* request, ::rsosor::generated::DealResponse* response, std::function<void(::grpc::Status)>) override;
      void Deal(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest* request, ::rsosor::generated::DealResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ValidatePlay(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest* request, ::rsosor::generated::PlayValidationResponse* response, std::function<void(::grpc::Status)>) override;
      void ValidatePlay(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest* request, ::rsosor::generated::PlayValidationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HandleTimeout(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest* request, ::rsosor::generated::TimeoutResponse* response, std::function<void(::grpc::Status)>) override;
      void HandleTimeout(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest* request, ::rsosor::generated::TimeoutResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Score(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest* request, ::rsosor::generated::ScoreResponse* response, std::function<void(::grpc::Status)>) override;
      void Score(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest* request, ::rsosor::generated::ScoreResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::DealResponse>* AsyncDealRaw(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::DealResponse>* PrepareAsyncDealRaw(::grpc::ClientContext* context, const ::rsosor::generated::DealRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayValidationResponse>* AsyncValidatePlayRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayValidationResponse>* PrepareAsyncValidatePlayRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayValidationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::TimeoutResponse>* AsyncHandleTimeoutRaw(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::TimeoutResponse>* PrepareAsyncHandleTimeoutRaw(::grpc::ClientContext* context, const ::rsosor::generated::TimeoutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ScoreResponse>* AsyncScoreRaw(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ScoreResponse>* PrepareAsyncScoreRaw(::grpc::ClientContext* context, const ::rsosor::generated::ScoreRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Deal_;
    const ::grpc::internal::RpcMethod rpcmethod_ValidatePlay_;
    const ::grpc::internal::RpcMethod rpcmethod_HandleTimeout_;
    const ::grpc::internal::RpcMethod rpcmethod_Score_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Deal cards to all players
    virtual ::grpc::Status Deal(::grpc::ServerContext* context, const ::rsosor::generated::DealRequest* request, ::rsosor::generated::DealResponse* response);
    // Validate whether a set of cards is a legal move
    virtual ::grpc::Status ValidatePlay(::grpc::ServerContext* context, const ::rsosor::generated::PlayValidationRequest* request, ::rsosor::generated::PlayValidationResponse* response);
    // Handle timeout when a player fails to move in time
    virtual ::grpc::Status HandleTimeout(::grpc::ServerContext* context, const ::rsosor::generated::TimeoutRequest* request, ::rsosor::generated::TimeoutResponse* response);
    // Score the game at the end of a match
    virtual ::grpc::Status Score(::grpc::ServerContext* context, const ::rsosor::generated::ScoreRequest* request, ::rsosor::generated::ScoreResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Deal() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::rsosor::generated::DealRequest* /*request*/, ::rsosor::generated::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeal(::grpc::ServerContext* context, ::rsosor::generated::DealRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::DealResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayValidationRequest* /*request*/, ::rsosor::generated::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidatePlay(::grpc::ServerContext* context, ::rsosor::generated::PlayValidationRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::PlayValidationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::rsosor::generated::TimeoutRequest* /*request*/, ::rsosor::generated::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandleTimeout(::grpc::ServerContext* context, ::rsosor::generated::TimeoutRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::TimeoutResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Score() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ScoreRequest* /*request*/, ::rsosor::generated::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScore(::grpc::ServerContext* context, ::rsosor::generated::ScoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::ScoreResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Deal<WithAsyncMethod_ValidatePlay<WithAsyncMethod_HandleTimeout<WithAsyncMethod_Score<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Deal() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::DealRequest, ::rsosor::generated::DealResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::DealRequest* request, ::rsosor::generated::DealResponse* response) { return this->Deal(context, request, response); }));}
    void SetMessageAllocatorFor_Deal(
        ::grpc::MessageAllocator< ::rsosor::generated::DealRequest, ::rsosor::generated::DealResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::DealRequest, ::rsosor::generated::DealResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::rsosor::generated::DealRequest* /*request*/, ::rsosor::generated::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Deal(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::DealRequest* /*request*/, ::rsosor::generated::DealResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::PlayValidationRequest, ::rsosor::generated::PlayValidationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::PlayValidationRequest* request, ::rsosor::generated::PlayValidationResponse* response) { return this->ValidatePlay(context, request, response); }));}
    void SetMessageAllocatorFor_ValidatePlay(
        ::grpc::MessageAllocator< ::rsosor::generated::PlayValidationRequest, ::rsosor::generated::PlayValidationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::PlayValidationRequest, ::rsosor::generated::PlayValidationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayValidationRequest* /*request*/, ::rsosor::generated::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ValidatePlay(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::PlayValidationRequest* /*request*/, ::rsosor::generated::PlayValidationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::TimeoutRequest, ::rsosor::generated::TimeoutResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::TimeoutRequest* request, ::rsosor::generated::TimeoutResponse* response) { return this->HandleTimeout(context, request, response); }));}
    void SetMessageAllocatorFor_HandleTimeout(
        ::grpc::MessageAllocator< ::rsosor::generated::TimeoutRequest, ::rsosor::generated::TimeoutResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::TimeoutRequest, ::rsosor::generated::TimeoutResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::rsosor::generated::TimeoutRequest* /*request*/, ::rsosor::generated::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HandleTimeout(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::TimeoutRequest* /*request*/, ::rsosor::generated::TimeoutResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Score() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::ScoreRequest, ::rsosor::generated::ScoreResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::ScoreRequest* request, ::rsosor::generated::ScoreResponse* response) { return this->Score(context, request, response); }));}
    void SetMessageAllocatorFor_Score(
        ::grpc::MessageAllocator< ::rsosor::generated::ScoreRequest, ::rsosor::generated::ScoreResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::ScoreRequest, ::rsosor::generated::ScoreResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ScoreRequest* /*request*/, ::rsosor::generated::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Score(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::ScoreRequest* /*request*/, ::rsosor::generated::ScoreResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Deal<WithCallbackMethod_ValidatePlay<WithCallbackMethod_HandleTimeout<WithCallbackMethod_Score<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Deal() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::rsosor::generated::DealRequest* /*request*/, ::rsosor::generated::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayValidationRequest* /*request*/, ::rsosor::generated::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::rsosor::generated::TimeoutRequest* /*request*/, ::rsosor::generated::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Score() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ScoreRequest* /*request*/, ::rsosor::generated::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Deal() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::rsosor::generated::DealRequest* /*request*/, ::rsosor::generated::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeal(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayValidationRequest* /*request*/, ::rsosor::generated::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidatePlay(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::rsosor::generated::TimeoutRequest* /*request*/, ::rsosor::generated::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHandleTimeout(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Score() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ScoreRequest* /*request*/, ::rsosor::generated::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Deal() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Deal(context, request, response); }));
    }
    ~WithRawCallbackMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::rsosor::generated::DealRequest* /*request*/, ::rsosor::generated::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Deal(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ValidatePlay(context, request, response); }));
    }
    ~WithRawCallbackMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayValidationRequest* /*request*/, ::rsosor::generated::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ValidatePlay(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HandleTimeout(context, request, response); }));
    }
    ~WithRawCallbackMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::rsosor::generated::TimeoutRequest* /*request*/, ::rsosor::generated::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HandleTimeout(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Score() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Score(context, request, response); }));
    }
    ~WithRawCallbackMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ScoreRequest* /*request*/, ::rsosor::generated::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Score(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Deal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Deal() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::DealRequest, ::rsosor::generated::DealResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::DealRequest, ::rsosor::generated::DealResponse>* streamer) {
                       return this->StreamedDeal(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Deal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Deal(::grpc::ServerContext* /*context*/, const ::rsosor::generated::DealRequest* /*request*/, ::rsosor::generated::DealResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeal(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::DealRequest,::rsosor::generated::DealResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ValidatePlay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ValidatePlay() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::PlayValidationRequest, ::rsosor::generated::PlayValidationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::PlayValidationRequest, ::rsosor::generated::PlayValidationResponse>* streamer) {
                       return this->StreamedValidatePlay(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ValidatePlay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ValidatePlay(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayValidationRequest* /*request*/, ::rsosor::generated::PlayValidationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedValidatePlay(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::PlayValidationRequest,::rsosor::generated::PlayValidationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HandleTimeout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HandleTimeout() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::TimeoutRequest, ::rsosor::generated::TimeoutResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::TimeoutRequest, ::rsosor::generated::TimeoutResponse>* streamer) {
                       return this->StreamedHandleTimeout(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HandleTimeout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HandleTimeout(::grpc::ServerContext* /*context*/, const ::rsosor::generated::TimeoutRequest* /*request*/, ::rsosor::generated::TimeoutResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHandleTimeout(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::TimeoutRequest,::rsosor::generated::TimeoutResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Score : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Score() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::ScoreRequest, ::rsosor::generated::ScoreResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::ScoreRequest, ::rsosor::generated::ScoreResponse>* streamer) {
                       return this->StreamedScore(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Score() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Score(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ScoreRequest* /*request*/, ::rsosor::generated::ScoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedScore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::ScoreRequest,::rsosor::generated::ScoreResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Deal<WithStreamedUnaryMethod_ValidatePlay<WithStreamedUnaryMethod_HandleTimeout<WithStreamedUnaryMethod_Score<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Deal<WithStreamedUnaryMethod_ValidatePlay<WithStreamedUnaryMethod_HandleTimeout<WithStreamedUnaryMethod_Score<Service > > > > StreamedService;
};

// ---------------------------------------------------------------------------
// 後台管理功能
// ---------------------------------------------------------------------------
class BigTwoManagementService final {
 public:
  static constexpr char const* service_full_name() {
    return "rsosor.generated.BigTwoManagementService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetRanking(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest& request, ::rsosor::generated::RankingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::RankingResponse>> AsyncGetRanking(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::RankingResponse>>(AsyncGetRankingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::RankingResponse>> PrepareAsyncGetRanking(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::RankingResponse>>(PrepareAsyncGetRankingRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPlayerWinRate(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest& request, ::rsosor::generated::PlayerRateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayerRateResponse>> AsyncGetPlayerWinRate(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayerRateResponse>>(AsyncGetPlayerWinRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayerRateResponse>> PrepareAsyncGetPlayerWinRate(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayerRateResponse>>(PrepareAsyncGetPlayerWinRateRaw(context, request, cq));
    }
    virtual ::grpc::Status GetActivityLog(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest& request, ::rsosor::generated::ActivityLogResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ActivityLogResponse>> AsyncGetActivityLog(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ActivityLogResponse>>(AsyncGetActivityLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ActivityLogResponse>> PrepareAsyncGetActivityLog(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ActivityLogResponse>>(PrepareAsyncGetActivityLogRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void GetRanking(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest* request, ::rsosor::generated::RankingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRanking(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest* request, ::rsosor::generated::RankingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetPlayerWinRate(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest* request, ::rsosor::generated::PlayerRateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPlayerWinRate(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest* request, ::rsosor::generated::PlayerRateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetActivityLog(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest* request, ::rsosor::generated::ActivityLogResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetActivityLog(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest* request, ::rsosor::generated::ActivityLogResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::RankingResponse>* AsyncGetRankingRaw(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::RankingResponse>* PrepareAsyncGetRankingRaw(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayerRateResponse>* AsyncGetPlayerWinRateRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::PlayerRateResponse>* PrepareAsyncGetPlayerWinRateRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ActivityLogResponse>* AsyncGetActivityLogRaw(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::rsosor::generated::ActivityLogResponse>* PrepareAsyncGetActivityLogRaw(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetRanking(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest& request, ::rsosor::generated::RankingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::RankingResponse>> AsyncGetRanking(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::RankingResponse>>(AsyncGetRankingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::RankingResponse>> PrepareAsyncGetRanking(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::RankingResponse>>(PrepareAsyncGetRankingRaw(context, request, cq));
    }
    ::grpc::Status GetPlayerWinRate(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest& request, ::rsosor::generated::PlayerRateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayerRateResponse>> AsyncGetPlayerWinRate(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayerRateResponse>>(AsyncGetPlayerWinRateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayerRateResponse>> PrepareAsyncGetPlayerWinRate(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayerRateResponse>>(PrepareAsyncGetPlayerWinRateRaw(context, request, cq));
    }
    ::grpc::Status GetActivityLog(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest& request, ::rsosor::generated::ActivityLogResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ActivityLogResponse>> AsyncGetActivityLog(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ActivityLogResponse>>(AsyncGetActivityLogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ActivityLogResponse>> PrepareAsyncGetActivityLog(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ActivityLogResponse>>(PrepareAsyncGetActivityLogRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetRanking(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest* request, ::rsosor::generated::RankingResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRanking(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest* request, ::rsosor::generated::RankingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetPlayerWinRate(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest* request, ::rsosor::generated::PlayerRateResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPlayerWinRate(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest* request, ::rsosor::generated::PlayerRateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetActivityLog(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest* request, ::rsosor::generated::ActivityLogResponse* response, std::function<void(::grpc::Status)>) override;
      void GetActivityLog(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest* request, ::rsosor::generated::ActivityLogResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::RankingResponse>* AsyncGetRankingRaw(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::RankingResponse>* PrepareAsyncGetRankingRaw(::grpc::ClientContext* context, const ::rsosor::generated::RankingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayerRateResponse>* AsyncGetPlayerWinRateRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::PlayerRateResponse>* PrepareAsyncGetPlayerWinRateRaw(::grpc::ClientContext* context, const ::rsosor::generated::PlayerRateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ActivityLogResponse>* AsyncGetActivityLogRaw(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::rsosor::generated::ActivityLogResponse>* PrepareAsyncGetActivityLogRaw(::grpc::ClientContext* context, const ::rsosor::generated::ActivityLogRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetRanking_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPlayerWinRate_;
    const ::grpc::internal::RpcMethod rpcmethod_GetActivityLog_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetRanking(::grpc::ServerContext* context, const ::rsosor::generated::RankingRequest* request, ::rsosor::generated::RankingResponse* response);
    virtual ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* context, const ::rsosor::generated::PlayerRateRequest* request, ::rsosor::generated::PlayerRateResponse* response);
    virtual ::grpc::Status GetActivityLog(::grpc::ServerContext* context, const ::rsosor::generated::ActivityLogRequest* request, ::rsosor::generated::ActivityLogResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRanking() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::rsosor::generated::RankingRequest* /*request*/, ::rsosor::generated::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRanking(::grpc::ServerContext* context, ::rsosor::generated::RankingRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::RankingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayerRateRequest* /*request*/, ::rsosor::generated::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerWinRate(::grpc::ServerContext* context, ::rsosor::generated::PlayerRateRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::PlayerRateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ActivityLogRequest* /*request*/, ::rsosor::generated::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActivityLog(::grpc::ServerContext* context, ::rsosor::generated::ActivityLogRequest* request, ::grpc::ServerAsyncResponseWriter< ::rsosor::generated::ActivityLogResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetRanking<WithAsyncMethod_GetPlayerWinRate<WithAsyncMethod_GetActivityLog<Service > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRanking() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::RankingRequest, ::rsosor::generated::RankingResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::RankingRequest* request, ::rsosor::generated::RankingResponse* response) { return this->GetRanking(context, request, response); }));}
    void SetMessageAllocatorFor_GetRanking(
        ::grpc::MessageAllocator< ::rsosor::generated::RankingRequest, ::rsosor::generated::RankingResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::RankingRequest, ::rsosor::generated::RankingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::rsosor::generated::RankingRequest* /*request*/, ::rsosor::generated::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRanking(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::RankingRequest* /*request*/, ::rsosor::generated::RankingResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::PlayerRateRequest, ::rsosor::generated::PlayerRateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::PlayerRateRequest* request, ::rsosor::generated::PlayerRateResponse* response) { return this->GetPlayerWinRate(context, request, response); }));}
    void SetMessageAllocatorFor_GetPlayerWinRate(
        ::grpc::MessageAllocator< ::rsosor::generated::PlayerRateRequest, ::rsosor::generated::PlayerRateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::PlayerRateRequest, ::rsosor::generated::PlayerRateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayerRateRequest* /*request*/, ::rsosor::generated::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPlayerWinRate(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::PlayerRateRequest* /*request*/, ::rsosor::generated::PlayerRateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::ActivityLogRequest, ::rsosor::generated::ActivityLogResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::rsosor::generated::ActivityLogRequest* request, ::rsosor::generated::ActivityLogResponse* response) { return this->GetActivityLog(context, request, response); }));}
    void SetMessageAllocatorFor_GetActivityLog(
        ::grpc::MessageAllocator< ::rsosor::generated::ActivityLogRequest, ::rsosor::generated::ActivityLogResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::rsosor::generated::ActivityLogRequest, ::rsosor::generated::ActivityLogResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ActivityLogRequest* /*request*/, ::rsosor::generated::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetActivityLog(
      ::grpc::CallbackServerContext* /*context*/, const ::rsosor::generated::ActivityLogRequest* /*request*/, ::rsosor::generated::ActivityLogResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetRanking<WithCallbackMethod_GetPlayerWinRate<WithCallbackMethod_GetActivityLog<Service > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRanking() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::rsosor::generated::RankingRequest* /*request*/, ::rsosor::generated::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayerRateRequest* /*request*/, ::rsosor::generated::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ActivityLogRequest* /*request*/, ::rsosor::generated::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRanking() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::rsosor::generated::RankingRequest* /*request*/, ::rsosor::generated::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRanking(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayerRateRequest* /*request*/, ::rsosor::generated::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPlayerWinRate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ActivityLogRequest* /*request*/, ::rsosor::generated::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActivityLog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRanking() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRanking(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::rsosor::generated::RankingRequest* /*request*/, ::rsosor::generated::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRanking(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPlayerWinRate(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayerRateRequest* /*request*/, ::rsosor::generated::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetPlayerWinRate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetActivityLog(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ActivityLogRequest* /*request*/, ::rsosor::generated::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetActivityLog(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRanking : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRanking() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::RankingRequest, ::rsosor::generated::RankingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::RankingRequest, ::rsosor::generated::RankingResponse>* streamer) {
                       return this->StreamedGetRanking(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRanking() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRanking(::grpc::ServerContext* /*context*/, const ::rsosor::generated::RankingRequest* /*request*/, ::rsosor::generated::RankingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRanking(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::RankingRequest,::rsosor::generated::RankingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPlayerWinRate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPlayerWinRate() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::PlayerRateRequest, ::rsosor::generated::PlayerRateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::PlayerRateRequest, ::rsosor::generated::PlayerRateResponse>* streamer) {
                       return this->StreamedGetPlayerWinRate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPlayerWinRate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPlayerWinRate(::grpc::ServerContext* /*context*/, const ::rsosor::generated::PlayerRateRequest* /*request*/, ::rsosor::generated::PlayerRateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPlayerWinRate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::PlayerRateRequest,::rsosor::generated::PlayerRateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetActivityLog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetActivityLog() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::rsosor::generated::ActivityLogRequest, ::rsosor::generated::ActivityLogResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::rsosor::generated::ActivityLogRequest, ::rsosor::generated::ActivityLogResponse>* streamer) {
                       return this->StreamedGetActivityLog(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetActivityLog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetActivityLog(::grpc::ServerContext* /*context*/, const ::rsosor::generated::ActivityLogRequest* /*request*/, ::rsosor::generated::ActivityLogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetActivityLog(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::rsosor::generated::ActivityLogRequest,::rsosor::generated::ActivityLogResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetRanking<WithStreamedUnaryMethod_GetPlayerWinRate<WithStreamedUnaryMethod_GetActivityLog<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetRanking<WithStreamedUnaryMethod_GetPlayerWinRate<WithStreamedUnaryMethod_GetActivityLog<Service > > > StreamedService;
};

}  // namespace generated
}  // namespace rsosor


#endif  // GRPC_bigtwo_2eproto__INCLUDED
